(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{205:function(t,e,l){"use strict";l.r(e);var a=l(0),i=Object(a.a)({},function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"多线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多线程","aria-hidden":"true"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("悲观锁与乐观锁(https://segmentfault.com/a/1190000016611415)")]),t._v(" "),l("ul",[l("li",[t._v("悲观锁：读取数据时认为其他线程会修改，所以预先加锁，MySQL的读锁、写锁、行锁，Java "),l("code",[t._v("synchronized")]),t._v("、可重入锁。")]),t._v(" "),l("li",[t._v("乐观锁：不加锁，但更新时会判断其他线程是否有修改，"),l("code",[t._v("CAS")]),t._v("（机器级别原子指令，对内存进行读-改-写操作）或版本号机制。")]),t._v(" "),l("li",[t._v("读多，冲突少，乐观锁；写多，冲突多，悲观锁。")])]),t._v(" "),l("p",[l("img",{attrs:{src:"/Users/yixu/Downloads/gitbook/juc.png",alt:"image-20190530133831879"}})])]),t._v(" "),l("li",[l("p",[t._v("synchronized、lock、volatile")]),t._v(" "),l("ul",[l("li",[t._v("synchronized：修饰方法或代码块，防止多线程同时访问，锁住的是()里的对象。")]),t._v(" "),l("li",[t._v("synchronized 与 lock的区别：接口与关键字；发生异常时自动释放锁 vs. 需手动释放；lock可以等待时响应中断，前者只能一直等待；lock可以知道获取锁的情况，可以提高"),l("code",[t._v("多线程读")]),t._v("的效率，同步竞争激烈时性能更好。")]),t._v(" "),l("li",[t._v("volatile：修饰被不同线程访问和修改的变量，确保各线程使用的是最新值。当变量需要更新时，先在进行修改的缓存A中修改为新值，然后通知其他缓存清除掉此变量，当其他缓存B中的线程读取此变量时，会向总线发送消息，这时存储新值的缓存A获取到消息，将新值穿给B。最后将新值写入内存。")]),t._v(" "),l("li",[t._v("可重入锁（synchronized和ReentrantLock，当前持有该锁的线程可以多次获取该锁，无需等待，重入计数，锁的分配基于线程而不是方法的调用）、读写锁（对资源的访问分为2个锁）、（等待时）可中断锁、公平锁（尽量按请求顺序）。")])])]),t._v(" "),l("li",[l("p",[t._v("多线程、线程池")]),t._v(" "),l("ul",[l("li",[t._v("解决多任务同时执行的需求，合理使用CPU资源。提高CPU利用率，提高响应速度，尤其是一些IO操作需要等待资源，这时候可以切换到其他线程。但有切换花销、内存空间、同步等问题。")]),t._v(" "),l("li",[t._v("线程池：一个线程池管理了一组工作线程， 同时它还包括了一个用于放置等待执行任务的任务队列（阻塞队列） 。开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以"),l("code",[t._v("避免反复创建线程对象所带来的性能开销，节省了系统的资源，更好并发控制，更好生命周期控制")]),t._v("。")]),t._v(" "),l("li",[t._v("Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。")])])]),t._v(" "),l("li",[l("p",[t._v("AQS(AbstractQueuedSynchronizer)")]),t._v(" "),l("p",[l("img",{attrs:{src:"/Users/yixu/Downloads/gitbook/aqs.png",alt:"image-20190530154902563"}})]),t._v(" "),l("ul",[l("li",[t._v("核心思想是 volatile int state 配合Unsafe工具对其原子性的操作来实现对当前锁的状态进行修改。基于 volatile state 和 FIFO线程等待队列实现。")]),t._v(" "),l("li",[t._v("2种资源共享方式：\n"),l("ul",[l("li",[t._v("Exclusive 独占（ReentrantLock，state初始为0，重入+1，为0时可获取锁）")]),t._v(" "),l("li",[t._v("Share 共享 (Semaphore，CountDownLatch(state初始为n，每个子任务线程执行完毕-1，state为0后调用进行后续动作))。")])])])])]),t._v(" "),l("li",[l("p",[t._v("ReentrantLock")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("基于非公平锁的独占锁实现：在获得同步锁时，同步器维护一个同步队列，"),l("code",[t._v("lock()、tryAcquire()两次CAS获取状态失败的线程都会被加入到队列尾部被阻塞")]),t._v("；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态，在释放同步状态时唤醒头节点的后继节点。")]),t._v(" "),l("p",[l("img",{attrs:{src:"/Users/yixu/Downloads/gitbook/fair&notfair.png",alt:"image-20190530172840237"}})]),t._v(" "),l("p",[l("img",{attrs:{src:"https:////upload-images.jianshu.io/upload_images/1593035-8400a3d403074d39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674",alt:"img"}})])])])])])])},[],!1,null,null,null);e.default=i.exports}}]);